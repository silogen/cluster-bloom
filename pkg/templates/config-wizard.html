<!DOCTYPE html>
<html>
<head>
    <title>Cluster-Bloom Configuration Wizard</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container { max-width: 800px; margin: 0 auto; }
        .header {
            background: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .config-section {
            background: white;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .section-header {
            background: #4CAF50;
            color: white;
            padding: 15px 20px;
            font-weight: bold;
            font-size: 18px;
        }
        .section-content { padding: 25px; }
        .form-group {
            margin-bottom: 25px;
        }
        .form-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        .form-group .description {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #4CAF50;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            transform: scale(1.2);
        }
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .btn:hover { background: #45a049; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .btn-secondary {
            background: #666;
            margin-right: 10px;
        }
        .btn-secondary:hover { background: #555; }
        .actions {
            text-align: center;
            padding: 30px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .conditional {
            display: none;
            opacity: 0.6;
        }
        .conditional.show {
            display: block;
            opacity: 1;
        }
        .progress-bar {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .progress-fill {
            height: 8px;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }
        .error { color: #d32f2f; margin-top: 5px; font-size: 14px; }
        .success { color: #2e7d32; margin-top: 5px; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Cluster-Bloom Configuration Wizard</h1>
            <p>Configure your Kubernetes cluster installation step by step</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: 10%"></div>
            </div>
            <div id="error-banner" style="display: none; border-radius: 4px; padding: 15px; margin-top: 15px;">
                <h3 id="error-title" style="margin: 0 0 10px 0;"></h3>
                <p id="error-message" style="margin: 0; color: #666;"></p>
                <p id="error-suggestion" style="margin: 10px 0 0 0; color: #666; font-style: italic;"></p>
            </div>
        </div>

        <form id="config-form" novalidate>
            <!-- Basic Configuration -->
            <div class="config-section">
                <div class="section-header">üìã Basic Configuration</div>
                <div class="section-content">
                    <div class="form-group">
                        <label for="FIRST_NODE">Node Type</label>
                        <div class="description">Is this the first node in the cluster? Select 'No' for additional nodes joining an existing cluster.</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="FIRST_NODE" name="FIRST_NODE" checked onchange="updateConditionals()">
                            <label for="FIRST_NODE">This is the first node in the cluster</label>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="GPU_NODE">GPU Support</label>
                        <div class="description">Does this node have GPUs? When enabled, ROCm will be installed and configured.</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="GPU_NODE" name="GPU_NODE" checked>
                            <label for="GPU_NODE">This node has GPUs (enable ROCm)</label>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="DOMAIN">Domain Name *</label>
                        <div class="description">Domain name for the cluster (e.g., cluster.example.com). Used for ingress configuration.</div>
                        <input type="text" id="DOMAIN" name="DOMAIN" placeholder="cluster.example.com"
                               pattern="[a-z0-9]([a-z0-9\-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9\-]*[a-z0-9])?)*"
                               title="Valid domain format: example.com or subdomain.example.com" required>
                        <small class="help-text" style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                            ‚úì Format: domain.com or sub.domain.com<br>
                            ‚úì Must start with alphanumeric, can contain hyphens<br>
                            ‚úó No special characters except dots and hyphens
                        </small>
                    </div>
                </div>
            </div>

            <!-- Additional Node Configuration -->
            <div class="config-section conditional" id="additional-node-section">
                <div class="section-header">üîó Additional Node Configuration</div>
                <div class="section-content">
                    <div class="form-group">
                        <label for="CONTROL_PLANE">Control Plane</label>
                        <div class="description">Should this node be a control plane node?</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="CONTROL_PLANE" name="CONTROL_PLANE">
                            <label for="CONTROL_PLANE">Make this a control plane node</label>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="SERVER_IP">Server IP Address *</label>
                        <div class="description">IP address of the RKE2 server (first node).</div>
                        <input type="text" id="SERVER_IP" name="SERVER_IP" placeholder="192.168.1.100"
                               pattern="^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
                               title="Valid IPv4 address format: xxx.xxx.xxx.xxx (0-255 for each octet)">
                        <small class="help-text" style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                            ‚úì Format: IPv4 address (e.g., 192.168.1.100)<br>
                            ‚úì Each octet: 0-255<br>
                            ‚úó No IPv6 addresses yet
                        </small>
                    </div>

                    <div class="form-group">
                        <label for="JOIN_TOKEN">Join Token *</label>
                        <div class="description">Token used to join additional nodes to the cluster.</div>
                        <input type="text" id="JOIN_TOKEN" name="JOIN_TOKEN" placeholder="K10xyz...">
                    </div>
                </div>
            </div>

            <!-- Storage Configuration -->
            <div class="config-section">
                <div class="section-header">üíæ Storage Configuration</div>
                <div class="section-content">
                    <div class="form-group">
                        <label for="NO_DISKS_FOR_CLUSTER">Skip Disk Operations</label>
                        <div class="description">Skip disk-related operations if you don't want automatic disk setup.</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="NO_DISKS_FOR_CLUSTER" name="NO_DISKS_FOR_CLUSTER">
                            <label for="NO_DISKS_FOR_CLUSTER">Skip disk operations</label>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="CLUSTER_DISKS">Disk Devices to Format</label>
                        <div class="description">Comma-separated list of disk devices to format and mount for Longhorn storage (e.g., /dev/sdb,/dev/nvme0n1). Leave empty for automatic selection.</div>
                        <input type="text" id="CLUSTER_DISKS" name="CLUSTER_DISKS" placeholder="/dev/sdb,/dev/nvme0n1"
                               pattern="^(/dev/[a-zA-Z0-9]+)(,/dev/[a-zA-Z0-9]+)*$|^$"
                               title="Format: /dev/xxx or comma-separated /dev/xxx,/dev/yyy (e.g., /dev/sdb,/dev/nvme0n1)">
                        <small class="help-text" style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                            <span id="longhorn-target-info-line">üõà Target Info: <span id="longhorn-previous-disks">{{ .LonghornPreviousDisks }}</span></span><br>
                            ‚úì Format: /dev/sdb or /dev/sdb,/dev/nvme0n1<br>
                            ‚úì Must be block devices (e.g., /dev/sd*, /dev/nvme*)<br>
                            ‚úì Leave empty for auto-detection<br>
                            ‚ö†Ô∏è Devices will be formatted - all data will be lost
                        </small>
                    </div>

                    <div class="form-group">
                        <label for="CLUSTER_PREMOUNTED_DISKS">Pre-Mounted Disk Paths</label>
                        <div class="description">Comma-separated list of absolute paths where disks are already mounted for Longhorn storage (e.g., /mnt/disk0,/mnt/disk1). Leave empty for automatic configuration.</div>
                        <input type="text" id="CLUSTER_PREMOUNTED_DISKS" name="CLUSTER_PREMOUNTED_DISKS" placeholder="/mnt/disk0,/mnt/disk1"
                               pattern="^/[^\s,]+(,/[^\s,]+)*$|^$"
                               title="Format: /path/to/mount or comma-separated absolute paths (must start with / and contain no spaces)">
                        <small class="help-text" style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                            üõà Disk => Mountpoint: {{ .LonghornPreviousMountpoints }}<br>
                            ‚úì Format: /mnt/disk0 or /mnt/disk0,/mnt/disk1<br>
                            ‚úì Must be absolute paths to existing mount points<br>
                            ‚úì Disks must already be formatted and mounted<br>
                            ‚úì Used as-is without formatting
                        </small>
                    </div>
                </div>
            </div>

            <!-- SSL/TLS Configuration -->
            <div class="config-section">
                <div class="section-header">üîí SSL/TLS Configuration</div>
                <div class="section-content">
                    <div class="form-group">
                        <label for="USE_CERT_MANAGER">Certificate Management</label>
                        <div class="description">Use cert-manager with Let's Encrypt for automatic TLS certificates.</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="USE_CERT_MANAGER" name="USE_CERT_MANAGER" onchange="updateConditionals()">
                            <label for="USE_CERT_MANAGER">Use cert-manager with Let's Encrypt</label>
                        </div>
                    </div>

                    <div class="form-group conditional" id="cert-option-section">
                        <label for="CERT_OPTION">Certificate Option *</label>
                        <div class="description">Choose how to handle TLS certificates when not using cert-manager.</div>
                        <select id="CERT_OPTION" name="CERT_OPTION" onchange="updateConditionals()">
                            <option value="">Choose an option...</option>
                            <option value="existing">Use existing certificate files</option>
                            <option value="generate">Generate self-signed certificates</option>
                        </select>
                    </div>

                    <div class="form-group conditional" id="tls-cert-section">
                        <label for="TLS_CERT">TLS Certificate Path *</label>
                        <div class="description">Path to TLS certificate file for ingress (PEM format).</div>
                        <input type="text" id="TLS_CERT" name="TLS_CERT" placeholder="/path/to/cert.pem"
                               pattern="^(/[a-zA-Z0-9._\\-]+)+\\.(pem|crt|cert)$|^$"
                               title="Must be an absolute path to a .pem, .crt, or .cert file">
                        <small class="help-text" style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                            ‚úì Format: Absolute path (starts with /)<br>
                            ‚úì File extensions: .pem, .crt, .cert<br>
                            ‚úì Must be readable by the user
                        </small>
                    </div>

                    <div class="form-group conditional" id="tls-key-section">
                        <label for="TLS_KEY">TLS Private Key Path *</label>
                        <div class="description">Path to TLS private key file for ingress (PEM format).</div>
                        <input type="text" id="TLS_KEY" name="TLS_KEY" placeholder="/path/to/key.pem"
                               pattern="^(/[a-zA-Z0-9._\\-]+)+\\.(pem|key)$|^$"
                               title="Must be an absolute path to a .pem or .key file">
                        <small class="help-text" style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                            ‚úì Format: Absolute path (starts with /)<br>
                            ‚úì File extensions: .pem, .key<br>
                            ‚úì Must be readable and should be protected (600 permissions)
                        </small>
                    </div>
                </div>
            </div>

            <!-- Advanced Configuration -->
            <div class="config-section">
                <div class="section-header">‚öôÔ∏è Advanced Configuration</div>
                <div class="section-content">
                    <div class="form-group">
                        <label for="OIDC_URL">OIDC Provider URL</label>
                        <div class="description">URL of the OIDC provider for authentication. Leave empty to skip OIDC configuration.</div>
                        <input type="url" id="OIDC_URL" name="OIDC_URL" placeholder="https://your-oidc-provider.com"
                               pattern="^https?://.*$|^$"
                               title="Must be a valid HTTP or HTTPS URL">
                        <small class="help-text" style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                            ‚úì Format: https://provider.com or http://provider.local<br>
                            ‚úì Must be accessible from the cluster<br>
                            ‚úì Leave empty to skip OIDC setup
                        </small>
                    </div>

                    <div class="form-group">
                        <label for="CLUSTERFORGE_RELEASE">ClusterForge Release</label>
                        <div class="description">ClusterForge release URL or 'none' to skip installation.</div>
                        <input type="text" id="CLUSTERFORGE_RELEASE" name="CLUSTERFORGE_RELEASE" value="https://github.com/silogen/cluster-forge/releases/download/deploy/deploy-release.tar.gz">
                    </div>

                    <div class="form-group">
                        <label for="DISABLED_STEPS">Disabled Steps</label>
                        <div class="description">Comma-separated list of steps to skip (e.g., SetupLonghornStep,SetupMetallbStep).</div>
                        <input type="text" id="DISABLED_STEPS" name="DISABLED_STEPS" placeholder="SetupLonghornStep,SetupMetallbStep">
                    </div>

                    <div class="form-group">
                        <label for="ENABLED_STEPS">Enabled Steps</label>
                        <div class="description">Comma-separated list of steps to run. If specified, only these steps will run.</div>
                        <input type="text" id="ENABLED_STEPS" name="ENABLED_STEPS" placeholder="SetupRKE2Step,SetupLonghornStep">
                    </div>
                </div>
            </div>

            <!-- CLI Options Help -->
            <div class="config-section">
                <div class="section-header">üíª Command Line Options</div>
                <div class="section-content">
                    <div class="description" style="margin-bottom: 15px;">
                        After generating your configuration, you can run bloom in different modes:
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; font-family: monospace; margin-bottom: 10px;">
                        <div style="margin-bottom: 8px;"><strong>Web interface mode (default):</strong></div>
                        <div style="color: #666;">bloom --config bloom.yaml</div>
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; font-family: monospace; margin-bottom: 10px;">
                        <div style="margin-bottom: 8px;"><strong>Terminal-only mode:</strong></div>
                        <div style="color: #666;">bloom cli --config bloom.yaml</div>
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; font-family: monospace;">
                        <div style="margin-bottom: 8px;"><strong>Automated mode (no interaction):</strong></div>
                        <div style="color: #666;">bloom --one-shot --config bloom.yaml</div>
                    </div>
                </div>
            </div>

            <div class="actions">
                <button type="button" class="btn btn-secondary" onclick="resetForm()">Reset</button>
                <button type="button" class="btn btn-secondary" onclick="saveConfig()">Save Configuration</button>
                <button type="submit" class="btn">Generate Configuration & Start Installation</button>
            </div>
        </form>

        <div id="result" style="display: none; margin-top: 20px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
    </div>

    <script>
        function updateConditionals() {
            const firstNode = document.getElementById('FIRST_NODE').checked;
            const useCertManager = document.getElementById('USE_CERT_MANAGER').checked;
            const certOption = document.getElementById('CERT_OPTION').value;

            // Show/hide additional node section
            const additionalNodeSection = document.getElementById('additional-node-section');
            const serverIPInput = document.getElementById('SERVER_IP');
            const joinTokenInput = document.getElementById('JOIN_TOKEN');

            if (firstNode) {
                additionalNodeSection.classList.remove('show');
                // Remove required from hidden additional node fields
                if (serverIPInput) serverIPInput.removeAttribute('required');
                if (joinTokenInput) joinTokenInput.removeAttribute('required');
            } else {
                additionalNodeSection.classList.add('show');
                // Add required to visible additional node fields
                if (serverIPInput) serverIPInput.setAttribute('required', 'required');
                if (joinTokenInput) joinTokenInput.setAttribute('required', 'required');
            }

            // Show/hide certificate options
            const certOptionSection = document.getElementById('cert-option-section');
            const tlsCertSection = document.getElementById('tls-cert-section');
            const tlsKeySection = document.getElementById('tls-key-section');
            const tlsCertInput = document.getElementById('TLS_CERT');
            const tlsKeyInput = document.getElementById('TLS_KEY');

            if (useCertManager) {
                certOptionSection.classList.remove('show');
                tlsCertSection.classList.remove('show');
                tlsKeySection.classList.remove('show');
                // Remove pattern validation from hidden certificate fields
                if (tlsCertInput) {
                    tlsCertInput.removeAttribute('pattern');
                    tlsCertInput.removeAttribute('required');
                    if (!window.prefilledData?.tls_cert) {
                        tlsCertInput.value = '';
                    }
                }
                if (tlsKeyInput) {
                    tlsKeyInput.removeAttribute('pattern');
                    tlsKeyInput.removeAttribute('required');
                    if (!window.prefilledData?.tls_key) {
                        tlsKeyInput.value = '';
                    }
                }
            } else {
                certOptionSection.classList.add('show');
                if (certOption === 'existing') {
                    tlsCertSection.classList.add('show');
                    tlsKeySection.classList.add('show');
                    // Restore pattern validation for visible certificate fields
                    if (tlsCertInput) {
                        tlsCertInput.setAttribute('pattern', '^(/[a-zA-Z0-9._\\-]+)+\\.(pem|crt|cert)$|^$');
                        if (window.prefilledData?.tls_cert) {
                            tlsCertInput.value = window.prefilledData.tls_cert;
                        }
                    }
                    if (tlsKeyInput) {
                        tlsKeyInput.setAttribute('pattern', '^(/[a-zA-Z0-9._\\-]+)+\\.(pem|key)$|^$');
                        if (window.prefilledData?.tls_key) {
                            tlsKeyInput.value = window.prefilledData.tls_key;
                        }
                    }
                } else {
                    tlsCertSection.classList.remove('show');
                    tlsKeySection.classList.remove('show');
                    // Remove pattern validation from hidden certificate fields
                    if (tlsCertInput) {
                        tlsCertInput.removeAttribute('pattern');
                        tlsCertInput.removeAttribute('required');
                        if (!window.prefilledData?.tls_cert) {
                            tlsCertInput.value = '';
                        }
                    }
                    if (tlsKeyInput) {
                        tlsKeyInput.removeAttribute('pattern');
                        tlsKeyInput.removeAttribute('required');
                        if (!window.prefilledData?.tls_key) {
                            tlsKeyInput.value = '';
                        }
                    }
                }
            }

            updateProgress();
        }

        function updateProgress() {
            const formData = new FormData(document.getElementById('config-form'));
            const inputs = document.querySelectorAll('#config-form input, #config-form select');
            let filled = 0;
            let total = 0;

            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    total++;
                    if (input.checked) filled++;
                } else {
                    const parent = input.closest('.form-group');
                    if (!parent.classList.contains('conditional') || parent.classList.contains('show')) {
                        total++;
                        if (input.value.trim()) filled++;
                    }
                }
            });

            const progress = Math.min(100, (filled / Math.max(total, 1)) * 100);
            document.getElementById('progress-fill').style.width = progress + '%';
        }

        function resetForm() {
            document.getElementById('config-form').reset();
            document.getElementById('FIRST_NODE').checked = true;
            document.getElementById('GPU_NODE').checked = true;
            document.getElementById('CLUSTERFORGE_RELEASE').value = 'https://github.com/silogen/cluster-forge/releases/download/deploy/deploy-release.tar.gz';
            updateConditionals();
        }

        // Shared validation helper: Check for root device conflict
        function checkRootDeviceConflict() {
            const selectedDisksValue = document.getElementById("CLUSTER_DISKS").value.trim();
            if (!selectedDisksValue || !window.prefilledData?.root_device) {
                return true; // No conflict
            }

            const selectedDisks = selectedDisksValue.split(",").map(d => d.trim());
            const rootDevice = window.prefilledData.root_device;
            const conflictingDisk = selectedDisks.find(disk => disk === rootDevice);

            if (conflictingDisk) {
                showErrorModal(
                    "‚ùå Cannot Use Root Device",
                    `You cannot select the root device <strong>${rootDevice}</strong> for Longhorn storage.<br>` +
                    "The root device contains your operating system and cannot be used for data storage.<br>" +
                    "Please select different disk devices for Longhorn storage.",
                    () => document.getElementById("CLUSTER_DISKS").focus()
                );
                return false;
            }
            return true;
        }

        // Shared validation helper: Validate form fields
        function validateForm(form) {
            if (form.checkValidity()) {
                return true;
            }

            const allInputs = form.querySelectorAll('input, select, textarea');
            allInputs.forEach(input => {
                if (!input.validity.valid) {
                    let message = '';
                    if (input.validity.patternMismatch) {
                        const helpText = input.nextElementSibling ? input.nextElementSibling.textContent : '';
                        message = 'Invalid format. ' + helpText;
                    } else if (input.validity.valueMissing) {
                        message = 'This field is required';
                    } else if (input.validity.typeMismatch) {
                        message = 'Please enter a valid value';
                    }
                    input.setCustomValidity(message);
                } else {
                    input.setCustomValidity('');
                }
            });

            form.reportValidity();
            return false;
        }

        // Shared helper: Collect form data into config object
        function collectFormData() {
            const formData = new FormData(document.getElementById('config-form'));
            const config = {};

            // Handle checkboxes
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                config[checkbox.name] = checkbox.checked;
            });

            // Handle other fields
            for (let [key, value] of formData.entries()) {
                const input = document.querySelector(`[name="${key}"]`);
                if (!input) continue;
                if (input.type !== 'checkbox' && value.trim()) {
                    config[key] = value.trim();
                }
            }

            return config;
        }

        // Shared helper: Show error modal
        function showErrorModal(title, message, onClose) {
            const errorDiv = document.createElement("div");
            errorDiv.innerHTML = `<h3 style='color: #d32f2f;'>${title}</h3>` +
                `<p style='color: #666;'>${message}</p>`;

            const modal = document.createElement("div");
            modal.style.cssText = "position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); " +
                "background: white; padding: 25px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); " +
                "z-index: 10000; max-width: 500px; max-height: 80vh; overflow-y: auto;";
            modal.appendChild(errorDiv);

            const closeBtn = document.createElement("button");
            closeBtn.textContent = "OK";
            closeBtn.style.cssText = "background: #4CAF50; color: white; border: none; padding: 10px 20px; " +
                "border-radius: 4px; cursor: pointer; margin-top: 15px; font-size: 16px;";
            closeBtn.onclick = () => {
                document.body.removeChild(modal);
                document.body.removeChild(overlay);
                if (onClose) onClose();
            };
            modal.appendChild(closeBtn);

            const overlay = document.createElement("div");
            overlay.style.cssText = "position: fixed; top: 0; left: 0; right: 0; bottom: 0; " +
                "background: rgba(0,0,0,0.5); z-index: 9999;";

            document.body.appendChild(overlay);
            document.body.appendChild(modal);
        }

        function saveConfig() {
            const form = document.getElementById('config-form');
            const saveBtn = event.target;

            // Use shared validation helpers
            if (!checkRootDeviceConflict()) return;
            if (!validateForm(form)) return;

            // Disable button and show loading state
            saveBtn.disabled = true;
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.style.background = '#999';

            // Collect form data using shared helper
            const config = collectFormData();

            // Submit configuration without installation
            fetch('/api/config-only', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(config)
            })
            .then(response => response.json())
            .then(data => {
                // Re-enable button
                saveBtn.disabled = false;
                saveBtn.textContent = originalText;
                saveBtn.style.background = '';

                if (data.success) {
                    // Show success feedback on button
                    saveBtn.textContent = '‚úÖ Saved!';
                    saveBtn.style.background = '#2e7d32';
                    setTimeout(() => {
                        saveBtn.textContent = originalText;
                        saveBtn.style.background = '';
                    }, 2000);

                    document.getElementById('result').innerHTML = `
                        <div class="success">
                            <h3>‚úÖ Configuration Saved!</h3>
                            <p>${data.message}</p>
                            <p><strong>File:</strong> ${data.file}</p>
                        </div>
                    `;
                    document.getElementById('result').style.display = 'block';

                    // Scroll to result
                    document.getElementById('result').scrollIntoView({ behavior: 'smooth' });
                } else {
                    saveBtn.textContent = '‚ùå Failed';
                    saveBtn.style.background = '#d32f2f';
                    setTimeout(() => {
                        saveBtn.textContent = originalText;
                        saveBtn.style.background = '';
                    }, 2000);

                    document.getElementById('result').innerHTML = `
                        <div class="error">
                            <h3>‚ùå Save Failed</h3>
                            <p>${data.error}</p>
                        </div>
                    `;
                    document.getElementById('result').style.display = 'block';
                    document.getElementById('result').scrollIntoView({ behavior: 'smooth' });
                }
            })
            .catch(error => {
                // Re-enable button
                saveBtn.disabled = false;
                saveBtn.textContent = '‚ùå Error';
                saveBtn.style.background = '#d32f2f';
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '';
                }, 2000);

                document.getElementById('result').innerHTML = `
                    <div class="error">
                        <h3>‚ùå Save Failed</h3>
                        <p>Failed to save configuration: ${error.message}</p>
                    </div>
                `;
                document.getElementById('result').style.display = 'block';
                document.getElementById('result').scrollIntoView({ behavior: 'smooth' });
            });
        }

        document.getElementById('config-form').addEventListener('submit', function(e) {
            e.preventDefault();

            // Use shared validation helpers
            if (!checkRootDeviceConflict()) return;

            const form = e.target;
            console.log('Form validity check:', form.checkValidity());

            if (!validateForm(form)) {
                console.error('Form has HTML5 validation errors');
                return;
            }

            // Collect form data using shared helper
            const config = collectFormData();

            // Validate required fields
            const firstNode = config.FIRST_NODE !== false;
            const useCertManager = config.USE_CERT_MANAGER === true;
            const certOption = config.CERT_OPTION;

            let errors = [];

            // Log all form fields for debugging
            console.log('=== Form Validation Debug ===');
            console.log('Configuration:', config);

            // Function to check and log field validation
            function validateField(fieldId, fieldName) {
                const element = document.getElementById(fieldId);
                if (element) {
                    const value = element.value;
                    const pattern = element.getAttribute('pattern');
                    const isValid = element.validity.valid;
                    const visibility = window.getComputedStyle(element.parentElement).display;
                    console.log(fieldName + ':', {
                        value: value,
                        pattern: pattern,
                        valid: isValid,
                        visible: visibility !== 'none',
                        validationMessage: element.validationMessage,
                        validity: element.validity
                    });
                    return isValid;
                }
                console.log(fieldName + ': Element not found');
                return true;
            }

            // Check all form fields for validation issues
            function checkAllFormFields() {
                console.log('=== Checking ALL Form Fields ===');
                const allInputs = document.querySelectorAll('input[pattern]');
                allInputs.forEach(input => {
                    if (!input.validity.valid) {
                        const parent = input.closest('.form-group');
                        const isVisible = parent && window.getComputedStyle(parent).display !== 'none';
                        console.error('INVALID FIELD:', {
                            id: input.id,
                            name: input.name,
                            value: input.value,
                            pattern: input.getAttribute('pattern'),
                            visible: isVisible,
                            validationMessage: input.validationMessage,
                            parentClass: parent?.className
                        });
                    }
                });
                console.log('=== End Form Field Check ===');
            }

            // Enhanced validation with detailed messages and logging
            if (!config.DOMAIN) {
                errors.push('‚ùå Domain is required - Please enter a valid domain name (e.g., cluster.example.com)');
            } else if (!validateField('DOMAIN', 'DOMAIN')) {
                errors.push('‚ùå Invalid domain format - Must be a valid domain like example.com or sub.example.com');
            }

            // SERVER_IP and JOIN_TOKEN are now validated by HTML5 required attribute
            // Only validate format if they have values
            if (!firstNode) {
                if (config.SERVER_IP && !validateField('SERVER_IP', 'SERVER_IP')) {
                    errors.push('‚ùå Invalid IP address format - Must be a valid IPv4 address (e.g., 192.168.1.100)');
                }
            }

            if (!useCertManager && !certOption) {
                errors.push('‚ùå Certificate option is required - Please select how to handle TLS certificates when not using cert-manager');
            }

            if (certOption === 'existing') {
                if (!config.TLS_CERT) {
                    errors.push('‚ùå TLS Certificate path is required - Please provide the path to your certificate file (e.g., /path/to/cert.pem)');
                } else if (!validateField('TLS_CERT', 'TLS_CERT')) {
                    errors.push('‚ùå Invalid certificate path - Must be an absolute path to a .pem, .crt, or .cert file');
                }
                if (!config.TLS_KEY) {
                    errors.push('‚ùå TLS Private Key path is required - Please provide the path to your key file (e.g., /path/to/key.pem)');
                } else if (!validateField('TLS_KEY', 'TLS_KEY')) {
                    errors.push('‚ùå Invalid key path - Must be an absolute path to a .pem or .key file');
                }
            }

            // Validate disk paths if provided
            if (config.CLUSTER_DISKS) {
                validateField('CLUSTER_DISKS', 'CLUSTER_DISKS');
                if (!document.getElementById('CLUSTER_DISKS').validity.valid) {
                    errors.push('‚ùå Invalid disk format - Must be /dev/xxx or comma-separated list like /dev/sdb,/dev/sdc');
                }
            }
            if (config.CLUSTER_PREMOUNTED_DISKS) {
                validateField('CLUSTER_PREMOUNTED_DISKS', 'CLUSTER_PREMOUNTED_DISKS');
                if (!document.getElementById('CLUSTER_PREMOUNTED_DISKS').validity.valid) {
                    errors.push('‚ùå Invalid mount path format - Must be absolute path (e.g., /mnt/disk0) or comma-separated list. Note: paths must be existing mount points');
                }
            }

            // Validate OIDC URL if provided
            if (config.OIDC_URL) {
                validateField('OIDC_URL', 'OIDC_URL');
                if (!document.getElementById('OIDC_URL').validity.valid) {
                    errors.push('‚ùå Invalid OIDC URL - Must be a valid HTTP or HTTPS URL');
                }
            }

            console.log('Validation errors:', errors);
            console.log('=== End Validation Debug ===');

            // Check all form fields for any HTML5 validation issues
            checkAllFormFields();

            // Double-check form validity right before submission
            const finalValidityCheck = document.getElementById('config-form').checkValidity();
            console.log('Final form validity check before submission:', finalValidityCheck);

            if (!finalValidityCheck) {
                console.error('Form became invalid between validation and submission!');
                // Find the invalid field
                const allInputs = document.querySelectorAll('input, select, textarea');
                allInputs.forEach(input => {
                    if (!input.validity.valid) {
                        console.error('INVALID FIELD FOUND:', {
                            name: input.name,
                            id: input.id,
                            value: input.value,
                            pattern: input.getAttribute('pattern'),
                            required: input.hasAttribute('required'),
                            validity: input.validity,
                            validationMessage: input.validationMessage
                        });
                    }
                });
                return;
            }

            if (errors.length > 0) {
                // Check if we're in one-shot mode
                if (window.isOneShot) {
                    // In one-shot mode, send error to server for automated handling
                    fetch('/api/validation-error', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ errors: errors })
                    });
                    return;
                } else {
                    // Show detailed error message with suggestions
                    const errorDiv = document.createElement('div');
                    errorDiv.innerHTML = '<h3 style="color: #d32f2f;">‚ùå Validation Failed</h3>' +
                        '<p style="color: #666;">Please fix the following issues:</p>' +
                        '<ul style="list-style: none; padding: 0;">' +
                        errors.map(e => '<li style="margin: 8px 0;">' + e + '</li>').join('') +
                        '</ul>' +
                        '<p style="color: #666; font-style: italic; margin-top: 15px;">üí° Tip: Hover over fields to see format requirements</p>';

                    // Create a better modal instead of alert
                    const modal = document.createElement('div');
                    modal.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); ' +
                        'background: white; padding: 25px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); ' +
                        'z-index: 10000; max-width: 600px; max-height: 80vh; overflow-y: auto;';
                    modal.appendChild(errorDiv);

                    const closeBtn = document.createElement('button');
                    closeBtn.textContent = 'OK';
                    closeBtn.style.cssText = 'background: #4CAF50; color: white; border: none; padding: 10px 20px; ' +
                        'border-radius: 4px; cursor: pointer; margin-top: 15px; font-size: 16px;';
                    closeBtn.onclick = () => {
                        document.body.removeChild(modal);
                        document.body.removeChild(overlay);
                        // Focus first invalid field
                        const firstError = errors[0];
                        if (firstError.includes('Domain')) document.getElementById('DOMAIN').focus();
                        else if (firstError.includes('Server IP')) document.getElementById('SERVER_IP').focus();
                        else if (firstError.includes('Join Token')) document.getElementById('JOIN_TOKEN').focus();
                        else if (firstError.includes('Certificate path')) document.getElementById('TLS_CERT').focus();
                        else if (firstError.includes('Key path')) document.getElementById('TLS_KEY').focus();
                    };
                    modal.appendChild(closeBtn);

                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; ' +
                        'background: rgba(0,0,0,0.5); z-index: 9999;';

                    document.body.appendChild(overlay);
                    document.body.appendChild(modal);
                    return;
                }
            }

            // Submit configuration
            console.log('About to submit configuration via fetch...');
            console.log('Config object:', config);

            try {
                console.log('Creating fetch request...');
                const fetchPromise = fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                console.log('Fetch request created, waiting for response...');
                fetchPromise
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('result').innerHTML = `
                        <div class="success">
                            <h3>‚úÖ Configuration Saved Successfully!</h3>
                            <p>Your configuration has been saved. The installation will begin shortly...</p>
                            <p><strong>Redirecting to installation monitor...</strong></p>
                        </div>
                    `;
                    document.getElementById('result').style.display = 'block';

                    // Redirect to monitor after 3 seconds
                    setTimeout(() => {
                        window.location.href = '/monitor';
                    }, 3000);
                } else {
                    document.getElementById('result').innerHTML = `
                        <div class="error">
                            <h3>‚ùå Configuration Error</h3>
                            <p>${data.error}</p>
                        </div>
                    `;
                    document.getElementById('result').style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Submission error details:', {
                    message: error.message,
                    stack: error.stack,
                    type: error.name,
                    error: error
                });

                // Try to identify what's causing the error
                if (error.message && error.message.includes('pattern')) {
                    console.error('Pattern validation error detected');
                    // Check ALL form fields one more time
                    const form = document.getElementById('config-form');
                    const allInputs = form.querySelectorAll('input, select, textarea');
                    console.error('Checking all', allInputs.length, 'form inputs:');

                    allInputs.forEach((input, index) => {
                        const parent = input.closest('.form-group');
                        const isVisible = parent ? window.getComputedStyle(parent).display !== 'none' : true;
                        const isInHiddenSection = input.closest('.form-section:not(.show)') !== null;

                        console.log('Field ' + index + ': ' + (input.name || input.id), {
                            type: input.type,
                            value: input.value,
                            pattern: input.getAttribute('pattern'),
                            required: input.hasAttribute('required'),
                            visible: isVisible,
                            inHiddenSection: isInHiddenSection,
                            validity: input.validity,
                            validationMessage: input.validationMessage,
                            checkValidity: input.checkValidity()
                        });
                    });
                }

                document.getElementById('result').innerHTML = `
                    <div class="error">
                        <h3>‚ùå Submission Failed</h3>
                        <p>Failed to submit configuration: ${error.message}</p>
                        <p style="font-size: 12px; color: #666;">Check browser console for detailed debugging information</p>
                    </div>
                `;
                document.getElementById('result').style.display = 'block';
            });
            } catch (e) {
                console.error('Exception thrown before fetch:', e);
                throw e;
            }
        });

        // Add event listeners for progress tracking and clearing validation
        document.querySelectorAll('#config-form input, #config-form select').forEach(input => {
            input.addEventListener('input', function() {
                updateProgress();
                // Clear any custom validation message when user starts typing
                this.setCustomValidity('');
            });
            input.addEventListener('change', function() {
                updateProgress();
                // Clear any custom validation message when field changes
                this.setCustomValidity('');
            });
        });

        // Check for errors on page load
        function checkForErrors() {
            fetch('/api/error')
                .then(response => response.json())
                .then(data => {
                    if (data.error && data.error !== '') {
                        const banner = document.getElementById('error-banner');
                        const title = document.getElementById('error-title');
                        const message = document.getElementById('error-message');
                        const suggestion = document.getElementById('error-suggestion');

                        message.textContent = data.error;

                        switch (data.errorType) {
                            case 'os':
                                banner.style.background = '#fff3e0';
                                banner.style.border = '2px solid #f57c00';
                                title.style.color = '#f57c00';
                                title.textContent = '‚ö†Ô∏è Unsupported Operating System';
                                suggestion.textContent = 'This server cannot run Cluster-Bloom due to OS compatibility. Please use a supported Ubuntu version (20.04, 22.04, or 24.04).';
                                break;
                            case 'system':
                                banner.style.background = '#fff3e0';
                                banner.style.border = '2px solid #f57c00';
                                title.style.color = '#f57c00';
                                title.textContent = '‚ö†Ô∏è System Requirements Not Met';
                                suggestion.textContent = 'This server does not meet the minimum system requirements. Please upgrade hardware or try a different server.';
                                break;
                            case 'config':
                                banner.style.background = '#ffebee';
                                banner.style.border = '2px solid #d32f2f';
                                title.style.color = '#d32f2f';
                                title.textContent = '‚ùå Configuration Error';
                                suggestion.textContent = 'Please update your configuration below and try again.';
                                break;
                            default:
                                banner.style.background = '#ffebee';
                                banner.style.border = '2px solid #d32f2f';
                                title.style.color = '#d32f2f';
                                title.textContent = '‚ùå Installation Failed';
                                suggestion.textContent = 'Please review the error and update your configuration if needed.';
                                break;
                        }

                        banner.style.display = 'block';
                    }
                })
                .catch(err => {
                    console.log('No error to display');
                });
        }

        // Load pre-filled configuration if available
        function loadPrefilledConfig() {
            console.log('Starting loadPrefilledConfig...');
            fetch('/api/prefilled-config')
                .then(response => {
                    console.log('API response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('API response data:', data);
                    if (data.hasPrefilled && data.config) {
                        console.log('Loading pre-filled configuration with', Object.keys(data.config).length, 'values');
                        window.prefilledData = data.config;  // Store for debugging

                        // Set global one-shot flag for validation error handling
                        window.isOneShot = data.oneShot;

                        // Show banner indicating pre-filled configuration
                        // we have three sources for the pre-filled info, glossing over some bugs 
                        // todo: update how we load default -vs- existing bloom.yaml content
                        const banner = document.getElementById('error-banner');
                        const title = document.getElementById('error-title');
                        const message = document.getElementById('error-message');
                        const suggestion = document.getElementById('error-suggestion');

                        if (banner && title && message && suggestion) {
                            banner.style.background = '#e8f5e8';
                            banner.style.border = '2px solid #2e7d32';
                            title.style.color = '#2e7d32';
                            title.textContent = 'üìÑ Configuration has been pre-filled';
                            message.textContent = 'Configuration has been pre-filled';

                            if (data.oneShot) {
                                suggestion.textContent = 'One-shot mode enabled - auto-proceeding...';
                            } else {
                                suggestion.textContent = 'Please update or review the configuration below and click "Generate Configuration & Start Installation" to proceed.';
                            }

                            banner.style.display = 'block';
                        }

                        // Fill form fields with pre-filled values
                        const config = data.config;
                        let fieldsSet = 0;
                        let fieldsNotFound = [];

                        // Boolean fields (checkboxes) - viper keys are lowercase
                        const booleanFields = {
                            'FIRST_NODE': 'first_node',
                            'GPU_NODE': 'gpu_node',
                            'CONTROL_PLANE': 'control_plane',
                            'NO_DISKS_FOR_CLUSTER': 'no_disks_for_cluster',
                            'USE_CERT_MANAGER': 'use_cert_manager'
                        };

                        Object.entries(booleanFields).forEach(([fieldId, configKey]) => {
                            const element = document.getElementById(fieldId);
                            if (element) {
                                if (config[configKey] !== undefined) {
                                    element.checked = config[configKey];
                                    console.log('Set checkbox', fieldId, 'to', config[configKey]);
                                    fieldsSet++;
                                }
                            } else {
                                fieldsNotFound.push(fieldId);
                            }
                        });

                        // String fields - map form IDs to viper keys (lowercase)
                        const stringFieldMap = {
                            'DOMAIN': 'domain',
                            'SERVER_IP': 'server_ip',
                            'JOIN_TOKEN': 'join_token',
                            'CLUSTER_DISKS': 'cluster_disks',
                            'CLUSTER_PREMOUNTED_DISKS': 'cluster_premounted_disks',
                            'OIDC_URL': 'oidc_url',
                            'CLUSTERFORGE_RELEASE': 'clusterforge_release',
                            'DISABLED_STEPS': 'disabled_steps',
                            'ENABLED_STEPS': 'enabled_steps',
                            'CERT_OPTION': 'cert_option',
                            'TLS_CERT': 'tls_cert',
                            'TLS_KEY': 'tls_key'
                        };

                        Object.entries(stringFieldMap).forEach(([fieldId, configKey]) => {
                            const element = document.getElementById(fieldId);
                            if (element) {
                                const value = config[configKey];
                                if (value !== undefined && value !== null && value !== '') {
                                    element.value = String(value);
                                    // Trigger change event to update any dependent fields
                                    element.dispatchEvent(new Event('change', { bubbles: true }));
                                    console.log('Set text field', fieldId, 'to', value);
                                    fieldsSet++;
                                }
                            } else {
                                fieldsNotFound.push(fieldId);
                            }
                        });

                        console.log('Fields successfully set:', fieldsSet);
                        if (fieldsNotFound.length > 0) {
                            console.warn('Fields not found in DOM:', fieldsNotFound);
                        }

                        // Update conditionals after filling
                        updateConditionals();
                        updateProgress();

                        // Auto-submit if in one-shot mode
                        if (data.oneShot) {
                            console.log('One-shot mode detected, preparing to auto-submit...');
                            setTimeout(() => {
                                const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
                                document.getElementById('config-form').dispatchEvent(submitEvent);
                            }, 500);
                        }
                    } else {
                        console.log('No pre-filled configuration available');
                        // Still need to call these when no prefilled config
                        updateConditionals();
                        updateProgress();
                    }
                })
                .catch(err => {
                    console.error('Error loading pre-filled configuration:', err);
                    // Still need to call these on error
                    updateConditionals();
                    updateProgress();
                });
        }

        // Style Longhorn disk info to highlight root partition
        function styleLonghornDiskInfo() {
            const diskInfoSpan = document.getElementById("longhorn-previous-disks");
            const targetInfoLine = document.getElementById("longhorn-target-info-line");
            
            if (!diskInfoSpan) return;
            
            const content = diskInfoSpan.textContent.trim();
            
            // Hide entire line if no content or "unused"
            if (!content || content === "" || content === "unused") {
                if (targetInfoLine) targetInfoLine.style.display = "none";
                return;
            }
            
            // Show the line since we have content
            if (targetInfoLine) targetInfoLine.style.display = "inline";
            
            // Parse format: "/dev/sdd => /,/mnt/wslg/distro,/snap,[swap]"
            const parts = content.split(/\s*=>\s*/);
            if (parts.length !== 2) return;
            
            const device = parts[0];
            const mountPoints = parts[1].split(",");
            
            // Check for dangerous mount points
            const hasRoot = mountPoints.some(mp => mp.trim() === "/");
            const hasSwap = mountPoints.some(mp => mp.trim().includes("[swap]"));
            
            if (hasRoot || hasSwap) {
                // Style root partition and swap partitions
                const styledMountPoints = mountPoints.map(mp => {
                    const trimmed = mp.trim();
                    if (trimmed === "/") {
                        return "<b style=\"color: red;\">/</b>";
                    } else if (trimmed.includes("[swap]")) {
                        return "<b style=\"color: orange;\">" + trimmed + "</b>";
                    }
                    return trimmed;
                }).join(",");
                
                const emoji = hasRoot ? "üö®" : (hasSwap ? "‚ö†Ô∏è" : "");
                diskInfoSpan.innerHTML = device + " => " + emoji + " " + styledMountPoints;
            }
        }
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('DOM ready, initializing...');
                // Don't call updateConditionals here - it's called inside loadPrefilledConfig
                loadPrefilledConfig();
                checkForErrors();
                styleLonghornDiskInfo();
                // updateProgress is called inside loadPrefilledConfig
            });
        } else {
            // DOM is already loaded
            console.log('DOM already loaded, initializing...');
            // Don't call updateConditionals here - it's called inside loadPrefilledConfig
            loadPrefilledConfig();
            checkForErrors();
                styleLonghornDiskInfo();
            // updateProgress is called inside loadPrefilledConfig
        }
    </script>
</body>
</html>